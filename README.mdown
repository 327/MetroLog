Overview
===
MetroLog is a lightweight logging framework designed for Metro-style apps. Although the API is based on
NLog and log4net, the intention is that it's a very basic logging system. 

The need for it to be basic comes from the fact that Metro-style is intentionally limited for very specific 
applications. This project came out of the fact that porting NLog to Metro-style is difficult because of it's 
incredibly rich feature set, most of which is not workable in Metro-style.

Out-of-the-box, logging operations are intended to send all log levels to `Debug.WriteLine` and [ETW](http://blogs.msdn.com/b/vancem/archive/2012/07/09/logging-your-own-etw-events-in-c-system-diagnostics-tracing-eventsource.aspx), 
and Error and Fatal levels to a file in the app's `LocalState` folder.

Although `Debug.WriteLine` seems limited, don't forget that you can use [DbgView](http://technet.microsoft.com/en-us/sysinternals/bb896647.aspx)
to view global system error messages. This is very helpful when chasing down application boot problems.

When `Debug.WriteLine` isn't enough, [Event Tracing for Windows](http://msdn.microsoft.com/en-us/library/windows/desktop/ff190903(v=vs.85).aspx) provides a high-performance way to obtain data.
Tools like [PerfView](http://www.microsoft.com/en-us/download/details.aspx?id=28567) and [Windows Performance Analyzer](http://msdn.microsoft.com/en-us/performance/cc752957.aspx)
can be useful as they also capture stack traces along with the event.

Documentation
===
The intention is that MetroLog is mostly compatible with NLog. Both the surface area and internal construction
should just about match.

Quick Start
---
After referencing the MetroLog and Metrolog._platform_ libraries, using MetroLog is very easy. Before any logging call, you'll need to
call `LogManagerFactory.Initialize`, optionally passing in any non-default settings. Then, obtain a reference to the `ILogManager` 
with `LogManagerFactory.DefaultLogManager`.

Once you have an `ILogManager`, you can call `GetLogger` on it to get an instance for each `Type` to use.

For those using DI or an IoC container, you can inject `ILogManager` by registering the value of the `DefaultLogManager` property
in your container setup. This is the recommended approach instead of using `LogManagerFactory.DefaultLogManager` thoughout your code.

###Example

	using System;
	using MetroLog;

	class LogExample
	{
		static void Main(string[] args)
		{
			// Initialize MetroLog using the defaults
			MetroLogFactory.Initialize();

			ILogManager logManager = MetroLogFactory.DefaultLogManager;

			// Inject the ILogManager manually
			SomeMagicClass c = new SomeMagicClass(logManager);
			c.DoMagic();
		}
	}

	class SomeMagicClass
	{
		private readonly ILogger _log;
		public SomeMagicClass(ILogManager logManager)
		{
			_log = logManager.GetLogger<SomeMagicClass>();
		}

		public void DoMagic()
		{
			// Log something interesting
			_log.Info("We are about to do magic!");			
		}
	}
		



Meta
===
This is an open source project that welcomes contributions/suggestions/bug reports from those who use it. 
If you have any ideas on how to improve the library, please contact [@mbrit](https://twitter.com/mbrit) or 
[@onovotny](https://twitter.com/onovotny).

MetroLog is distributed under the MIT license. 
